: main
  randomize-map
	loop
  again


#####################
# Level definitions
# We can only have one for obvious space constraints :(
# 0 = nothing
# 1 = wall

: map
  0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01
  0x01 0x01 0x00 0x00 0x00 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x00 0x00 0x00 0x01
  0x01 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x01 0x00 0x01
  0x01 0x00 0x01 0x01 0x01 0x01 0x00 0x01 0x01 0x00 0x01 0x00 0x01 0x00 0x00 0x01
  0x01 0x00 0x01 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 0x00 0x01 0x01
  0x01 0x00 0x00 0x00 0x00 0x01 0x01 0x00 0x01 0x01 0x01 0x00 0x00 0x00 0x00 0x01
  0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x00 0x01 0x01 0x01 0x01 0x00 0x01 0x01 0x01
  0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01 0x01


:alias X vA
:alias Y vB
:alias FRONTIER vC
:alias RUN vD

: randomize-map
  i := map
  v1 := 0
  v0 := 1
: rm-clear-loop
  save v0
	#if SCHIP
  	i += v0
	#end
  v1 += 1
  if v1 < 128 then jump rm-clear-loop

	v0 := 7
	rand
	X := v0
	X <<= X
	X += 1

	v0 := 3
	rand
	Y := v0
	Y <<= Y
	Y += 1

  RUN := 0

  v0 := 6
  rm-write
  jump rm-mark-frontiers

: rm-mark-spot
  # Mark spot as new hallway
  v0 := 0
  rm-write

: rm-mark-frontiers
  # Mark the new frontier
  if Y > 2 begin # Valid coordinate?
    Y -= 2
    rm-read
    if v0 == 1 begin # Empty spot?
      v0 := 0x12
      rm-write
      FRONTIER += 1
    end
    Y += 2
  end
  if X > 2 begin
    X -= 2
    rm-read
    if v0 == 1 begin
      v0 := 0x13
      rm-write
      FRONTIER += 1
    end
    X += 2
  end
  if X < 13 begin
    X += 2
    rm-read
    if v0 == 1 begin
      v0 := 0x14
      rm-write
      FRONTIER += 1
    end
    X -= 2
  end
  if Y < 5 begin
    Y += 2
    rm-read
    if v0 == 1 begin
      v0 := 0x15
      rm-write
      FRONTIER += 1
    end
    Y -= 2
  end

  clear
  render-map
  RUN += 1
  #wait-key-press

  if FRONTIER == 0 begin
    :monitor map 128
    v0 := 7
    rm-write
    return
  end

  v0 := FRONTIER
  rand
  if v0 == FRONTIER begin
    # Error state where we should never be
    :breakpoint error
    v0 := 0 # Dummy opcode
  end
  if v0 > FRONTIER begin
    # Error state where we should never be
    :breakpoint error
    v0 := 0 # Dummy opcode
  end
  v4 := v0
  X := 1
  Y := 1
  v2 := 0x10
  loop
    rm-read
    v3 := v0
    v0 &= v2
    if v0 != 0 begin
      if v4 == 0 begin
        FRONTIER -= 1
        v0 := 0
        if v3 == 0x12 begin
          Y += 1
          rm-write
          Y -= 1
        end
        if v3 == 0x13 begin
          X += 1
          rm-write
          X -= 1
        end
        if v3 == 0x14 begin
          X -= 1
          rm-write
          X += 1
        end
        if v3 == 0x15 begin
          Y -= 1
          rm-write
          Y += 1
        end
        jump rm-mark-spot
      end
      v4 -= 1
    end
    X += 1
    if X == 16 begin
      X := 0
      Y += 1
      if Y == 7 begin
        # Error state where we should never be
        :breakpoint error
        v0 := 0 # Dummy opcode
      end
    end
  again

# Read map at X,Y into v0
# Destroys i
: rm-read
  i := map
  i += X
  v0 := Y
  v0 <<= v0
  v0 <<= v0
  v0 <<= v0
  v0 <<= v0
  i += v0
  load v0
  return

# Write v0 into map at X,Y
# Destroys v1, i
: rm-write
  i := map
  i += X
  v1 := Y
  v1 <<= v1
  v1 <<= v1
  v1 <<= v1
  v1 <<= v1
  i += v1
  save v0
  return

#####################
# Get a random number
# Input: v0 is upper bound (exclusive)
# Output: v0 is random number
# Destroys: v1, v2, v3
: rand
	# Create bitmask
	v2 := 0
	v3 := v0
: rand-mask
	v3 >>= v3
	v2 <<= v2
	v2 += 1
	if v3 != 0 then jump rand-mask
  loop
  	v1 := random 255
  	v1 &= v2
  	if v1 < v0 begin
      v0 := v1
  	  return
    end
  again




# Blocking "press any key" routine
# Returns pressed key in v5
: wait-key-press
  vA := 0
: wait-key-press-loop
  if vA key then jump wait-key-release
  vA += 1
  if vA != 16 then jump wait-key-press-loop
  jump wait-key-press

: wait-key-release
  vA := 0
: wait-key-release-loop
  if vA key then jump wait-key-release-loop
  vA += 1
  if vA != 16 then jump wait-key-release-loop
  return





: render-map
  :alias X v6
  :alias Y v7
  X := 0
  Y := 0
: render-map-loop
  # Look up value at X,Y
  v0 := X
  v1 := Y
  map-get
  # Don't show tile if its hidden
  v1 := 0b00001000
  v2 := 0b00000111
  v1 &= v0
  v2 &= v0
  if v1 == 0b00001000 begin
    # Hidden normal stuff looks like hallway
    v0 := 0x00
    # Hidden hallways look like FRONTIER
    if v2 == 0x00 then v0 := 0x01
    # Hidden coins look like FRONTIER
    if v2 == 0x06 then v0 := 0x01
  end
  # Mask out three relevant bits
  v1 := 0b00000111
  v0 &= v1
  # Get pointer to right sprite
  # Sprites are 8 bytes, so sprite = tiles + map value * 4
  i := long top-down-tiles
  v0 <<= v0
  v0 <<= v0
  v0 <<= v0
  i += v0
  # Get coordinates in display space (x4)
  v4 := X
  v4 <<= v4
  v4 <<= v4
  v5 := Y
  v5 <<= v5
  v5 <<= v5
  # Render
  sprite v4 v5 4
  X += 1
  if X < 16 then jump render-map-loop
  # Next row
  X := 0
  Y += 1
  if Y < 8 then jump render-map-loop
  # Done
  return


#####################
# Query the map for the value at a given position
# Input: X in v0, Y in v1 (destructive)
# Output: map value in v0
# Destroys: v0 - v3, i
: map-get
  i := map
  i += v0
  v1 <<= v1
  v1 <<= v1
  v1 <<= v1
  v1 <<= v1
  i += v1
  load v0
  return


#####################
# Tiles for the mini-map

: top-down-tiles

# empty
  0b11110000
  0b11110000
  0b11110000
  0b11110000

  0b00000000
  0b00000000
  0b00000000
  0b00000000

# wall
  0b00000000
  0b00000000
  0b00000000
  0b00000000

  0b01010000
  0b10100000
  0b01010000
  0b10100000

# player starting position
  0b00000000
  0b00000000
  0b00000000
  0b01100000

  0b00000000
  0b01100000
  0b01100000
  0b00000000

# finish
  0b00000000
  0b00010000
  0b00010000
  0b00000000

  0b01100000
  0b11110000
  0b10010000
  0b10010000

# button
  0b00000000
  0b10000000
  0b10000000
  0b00000000

  0b00000000
  0b01100000
  0b01100000
  0b00000000

# snake
  0b01100000
  0b00000000
  0b00000000
  0b00000000

  0b00100000
  0b01000000
  0b00100000
  0b01000000

# Coins are not visible on the map
  0b11110000
  0b10110000
  0b11010000
  0b11110000

  0b00000000
  0b00000000
  0b00000000
  0b00000000

# Coins are not visible on the map
  0b11110000
  0b11010000
  0b10110000
  0b11110000

  0b00000000
  0b00000000
  0b00000000
  0b00000000
